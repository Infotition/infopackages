"use strict";(self.webpackChunkinfopackages=self.webpackChunkinfopackages||[]).push([[802],{4327:function(e,t,n){n.d(t,{f:function(){return c}});var r=n(1934),o=n(2784),i="content-editable_aXCn",a=n(2322),c=function(e){var t=e.html,n=void 0===t?"Edit me!":t,c=e.Tag,s=void 0===c?"div":c,l=e.readonly,u=void 0!==l&&l,p=e.spellcheck,d=void 0!==p&&p,f=e.lang,m=void 0===f?"en":f,h=e.headless,b=void 0!==h&&h,g=e.className,y=e.style,v=e.onChange,k=e.onBlur,w=e.onFocus,C=e.onKey,O=(0,o.useRef)(n),P=function(e,t){t&&t(e.innerHTML)};return(0,a.jsx)(s,{"data-testid":"content-editable",dangerouslySetInnerHTML:{__html:O.current},contentEditable:!u,onInput:function(e){var t=e.target;return P(t,v)},onBlur:function(e){var t=e.target;return P(t,k)},onFocus:function(e){var t=e.target;return P(t,w)},onKeyDown:function(e){return C&&C("down",e)},onKeyUp:function(e){return C&&C("up",e)},className:(0,r.A)(g,!b&&i),lang:m,spellCheck:d,style:y})}},1934:function(e,t){var n=function(e){for(var t=[],n=0,r=Object.entries(e);n<r.length;n++){var o=r[n],i=o[0];o[1]&&t.push(i)}return t.join(" ")||void 0};t.A=function(){for(var e,t=[],r=arguments.length-1;r>=0;--r)(e=r<0||arguments.length<=r?void 0:arguments[r])&&"boolean"!=typeof e&&t.push("string"==typeof e?e:n(e));return t.join(" ")||void 0}},1704:function(e,t,n){n.r(t),n.d(t,{RerenderDemoRef:function(){return h},RerenderDemoState:function(){return m},assets:function(){return d},contentTitle:function(){return u},default:function(){return g},frontMatter:function(){return l},metadata:function(){return p},toc:function(){return f}});var r=n(7896),o=n(1461),i=n(2784),a=n(876),c=n(4327),s=["components"],l={id:"contenteditable-performance",title:"Performance",description:"Performance optimisations for the component.",sidebar_position:2},u="Performance considerations",p={unversionedId:"components/react-contenteditable/contenteditable-performance",id:"components/react-contenteditable/contenteditable-performance",title:"Performance",description:"Performance optimisations for the component.",source:"@site/docs/components/react-contenteditable/2-performance.mdx",sourceDirName:"components/react-contenteditable",slug:"/components/react-contenteditable/contenteditable-performance",permalink:"/infopackages/components/react-contenteditable/contenteditable-performance",draft:!1,editUrl:"https://github.com/Infotition/infopackages/docs/components/react-contenteditable/2-performance.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{id:"contenteditable-performance",title:"Performance",description:"Performance optimisations for the component.",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Getting started",permalink:"/infopackages/components/react-contenteditable/contenteditable-getting-started"},next:{title:"API Reference",permalink:"/infopackages/components/react-contenteditable/contenteditable-api-reference"}},d={},f=[],m=function(){var e=(0,i.useRef)(0),t=(0,i.useState)("Edit me!"),n=t[0],r=t[1];return e.current+=1,(0,a.kt)("div",null,(0,a.kt)(c.f,{html:n,onChange:r,mdxType:"ContentEditable"}),"Component rerenders: ",(0,a.kt)("strong",null,e.current))},h=function(){var e=(0,i.useRef)(0),t=(0,i.useRef)("Edit me!");e.current+=1;return(0,a.kt)("div",null,(0,a.kt)(c.f,{html:t.current,onChange:function(e){t.current=e},mdxType:"ContentEditable"}),"Component rerenders: ",(0,a.kt)("strong",null,e.current))},b={toc:f,RerenderDemoState:m,RerenderDemoRef:h};function g(e){var t=e.components,n=(0,o.Z)(e,s);return(0,a.kt)("wrapper",(0,r.Z)({},b,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"performance-considerations"},"Performance considerations"),(0,a.kt)("p",null,"By default, the component does not use state internally to keep track of text changes. It uses react's ",(0,a.kt)("inlineCode",{parentName:"p"},"useRef")," hook to reduce rerenders.\nHowever, the initial example used ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," which causes rerender of the parent and so all children components. This was only shown\nfor simplicity but should be avoided if possible to reduce render times (especially for big block posts). The following example will\nshow the rerendering problem with ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," and a simple solution to improve the performance."),(0,a.kt)(m,{mdxType:"RerenderDemoState"}),(0,a.kt)("br",null),(0,a.kt)("p",null,"Here you can see, that the parent element get's rerendered every time the user types into the editable field. To be fair, 99% of the times\nthis won't cause any problems because react is really performant. But why shoot sparrows with cannons if there is an better option."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { ContentEditable } from '@infotition/react-contenteditable';\nimport { useRef, FunctionComponent } from 'react';\n\ntype EditorProps = { initialContent: string; }\n\nconst Editor: FunctionComponent<EditorProps> = ({initialContent}) => {\n  const content = useRef(initialContent);\n\n  const handleChange = (val: string) => {\n    content.current = val;\n  }\n\n  return <ContentEditable html={content.current} onChange={handleChange} />;\n}\n\nexport default Editor;\n")),(0,a.kt)("p",null,"This example uses ",(0,a.kt)("inlineCode",{parentName:"p"},"useRef")," to keep track of the changes. This causes to rerenderings. If you want to get the current value, you can access it with ",(0,a.kt)("inlineCode",{parentName:"p"},"content.current"),"."),(0,a.kt)(h,{mdxType:"RerenderDemoRef"}),(0,a.kt)("br",null),(0,a.kt)("p",null,"As you can see, the component doesn't get rerenders after it was mounted... and this without even using stuff like ",(0,a.kt)("inlineCode",{parentName:"p"},"useMemo"),"."))}g.isMDXComponent=!0},876:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return f}});var r=n(2784);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),d=l(n),f=o,m=d["".concat(s,".").concat(f)]||d[f]||p[f]||i;return n?r.createElement(m,a(a({ref:t},u),{},{components:n})):r.createElement(m,a({ref:t},u))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=d;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,a[1]=c;for(var l=2;l<i;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);